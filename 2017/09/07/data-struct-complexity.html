<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="时间复杂度(1)"/>




  <meta name="keywords" content="数据结构与算法," />





  <link rel="alternative" href="/default" title="Seymour" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=10001" />



<link rel="canonical" href="http://yoursite.com/2017/09/07/data-struct-complexity.html"/>


<meta name="description" content="其实我在讨论算法的时候，总会说一下这个算法的时间复杂度是O(1)或者O(logN)，很多人看到这个大O这个符号一脸懵逼，那我就来简单说一下这个大O符号含义及如何计算的。
大O符号的数学基础在我们实际应用中，计算某个问题的精确解可能非常困难，比如物理设备的差异，网络环境的差异等等。此时，会有一个可行性方案是不直接寻找精确解，转而寻找可接受的估值(estimate)。
首先了解一下函数比较，
比较：f">
<meta property="og:type" content="article">
<meta property="og:title" content="时间复杂度(1)">
<meta property="og:url" content="http://yoursite.com/2017/09/07/data-struct-complexity.html">
<meta property="og:site_name" content="Seymour">
<meta property="og:description" content="其实我在讨论算法的时候，总会说一下这个算法的时间复杂度是O(1)或者O(logN)，很多人看到这个大O这个符号一脸懵逼，那我就来简单说一下这个大O符号含义及如何计算的。
大O符号的数学基础在我们实际应用中，计算某个问题的精确解可能非常困难，比如物理设备的差异，网络环境的差异等等。此时，会有一个可行性方案是不直接寻找精确解，转而寻找可接受的估值(estimate)。
首先了解一下函数比较，
比较：f">
<meta property="og:image" content="http://yoursite.com/images/data-struct-complexity/post-2.png">
<meta property="og:updated_time" content="2017-09-11T11:45:49.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="时间复杂度(1)">
<meta name="twitter:description" content="其实我在讨论算法的时候，总会说一下这个算法的时间复杂度是O(1)或者O(logN)，很多人看到这个大O这个符号一脸懵逼，那我就来简单说一下这个大O符号含义及如何计算的。
大O符号的数学基础在我们实际应用中，计算某个问题的精确解可能非常困难，比如物理设备的差异，网络环境的差异等等。此时，会有一个可行性方案是不直接寻找精确解，转而寻找可接受的估值(estimate)。
首先了解一下函数比较，
比较：f">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=10001" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> 时间复杂度(1) - Seymour </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Seymour</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/github">
                            
                            
                                Github
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          时间复杂度(1)
        
      </h1>

      <time class="post-time">
          Sep 7 2017
      </time>
    </header>



    
            <div class="post-content">
            <p>其实我在讨论算法的时候，总会说一下这个算法的时间复杂度是O(1)或者O(logN)，很多人看到这个大O这个符号一脸懵逼，那我就来简单说一下这个大O符号含义及如何计算的。</p>
<h3 id="大O符号的数学基础">大O符号的数学基础</h3><p>在我们实际应用中，计算某个问题的精确解可能非常困难，比如物理设备的差异，网络环境的差异等等。此时，会有一个可行性方案是不直接寻找精确解，转而寻找可接受的估值(estimate)。</p>
<p><strong>首先了解一下函数比较，</strong></p>
<p>比较：f(n) = 5n以及g(n)=n<sup>2</sup>，其中n ∈ N 为自然数。</p>
<p>首先看一下这两个函数的线形图。</p>
<p><img src="/images/data-struct-complexity/post-2.png" alt="图1"></p>
<p>有图中可以看出，在n&gt;5时，g(n)远大于f(n)，所以n-&gt;∞时，f(n)的增长不快于g(n)。所以在这里定义大O符号，<strong>f(n)=O(g(n))</strong>。</p>
<p>函数的渐进比较定义：</p>
<blockquote>
<p>定义：f,g: N -&gt; R是两个自然数到实数的单变量方程f(n)=O(g(n))，表示存在常数n<sub>0</sub>和C，使得对所有n≥n<sub>0</sub>，不等式|f(n)|≤C·g(n)成立。</p>
</blockquote>
<p>对于一个<strong>f(n)=O(g(n))</strong>来说，其实含义就是函数f(n)的增长率小于等于(≤)函数g(n)的增长率。</p>
<p>其实大O表示法，表达函数增长率上限。</p>
<p>举个栗子，n<sup>3</sup>增长比n<sup>2</sup>快，因此我们可以说n<sup>2</sup>=O(n<sup>3</sup>)。</p>
<p>类似的符号，还有Ω(omega)，Θ(theta)，o(小o)。</p>
<p><strong>f(n) = Ω(g(n))</strong>，就是说函数f(n)的增长率大于等于(≥)函数g(n)的增长率。<br><strong>f(n) = Θ(g(n))</strong>，就是说函数f(n)的增长率等于函数g(n)的增长率。<br><strong>f(n) = o(g(n))</strong>，就是说函数f(n)的增长率小于(＜)函数g(n)的增长率。</p>
<h4 id="关于函数渐进比较相关法则">关于函数渐进比较相关法则</h4><p>法则1：</p>
<blockquote>
<p>如果T1(n) = O(f(n))且T2 = O(g(n))，那么，</p>
<ol>
<li>T1(n) + T2(n) = max(O(f(n)) + O(g(n)))。</li>
<li>T1(n) * T2(n) = O(f(n) * g(n))。</li>
</ol>
</blockquote>
<p>法则2：</p>
<blockquote>
<p>如果T(n)是一个k的多项式，则T(n) = Θ(n<sup>k</sup>)。</p>
</blockquote>
<p>法则3：</p>
<blockquote>
<p>对任意常数k，log<sup>k</sup>N = O(N)。</p>
</blockquote>
<p>另外需要注意的是：<strong>不要将常数或低阶项放进大O符号内。</strong>不要写成T(n) = O(2n<sup>2</sup>)或者T(n) = O(n<sup>2</sup> + n)，要写成T(n) = O(n<sup>2</sup>)。</p>
<h3 id="时间复杂度定义">时间复杂度定义</h3><blockquote>
<p>算法由<strong>控制结构（顺序、分支和循环）</strong>+ <strong>原操作（数据类型固有的操作）</strong> 构成，则算法时间取决于两者的综合效果。通常会选取一种对于所研究的问题来说是基本操作的原操作，以该原操作重复执行的次数作为算法的时间量度。<br>一般情况下，算法中的基本操作重复执行次数是问题规模n的某个函数f(n)，算法的时间量度记作： T(n)=O(f(n))。称作算法的<strong>渐近时间复杂度(asymptotic time complexity)</strong>，简称为<strong>时间复杂度</strong>。</p>
</blockquote>
<p>其实我们在计算算法的时间复杂度的时候，只考虑对于问题规模n的增长率，则难以在精确计算基本操作执行次数的情况下，只需求出它关于n的增长率或阶即可，而我们平常讨论算法大多数是在<strong>最坏情况下的时间复杂度</strong>(就是所谓执行时间的上界)。</p>
<p>先来看个代码片段(来源数据结构与算法-C语言描述15页)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, PartialSum;</span><br><span class="line"></span><br><span class="line">	PartialSum = <span class="number">0</span>;					<span class="comment">/* 1 */</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n;i++)				<span class="comment">/* 2 */</span></span><br><span class="line">		PartialSum += i * i * i;	<span class="comment">/* 3 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> PartialSum;				<span class="comment">/* 4 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分析一下计算时间复杂度基本步骤。</p>
<p><strong>1. 计算出基本操作的执行次数T(n)。</strong></p>
<p>基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。在做算法分析时，一般默认为考虑最坏的情况。</p>
<p>注释1和注释4各占了一个时间单元，注释3每执行一次占用4个时间单元(两次乘法，一次加法和一次赋值)，而执行n次功占用4n个时间单元。注释2来说，初始化i占用一个时间单元、测试i≤n占用n+1个时间单元，对i的自增运算n个时间单元。我们忽略函数的返回值，得到总量<code>T(n) = 6n+4</code>。</p>
<p><strong>2. 计算出T(n)的数量级。</strong></p>
<p>求T(n)的数量级，只要将T(n)进行如下一些操作：忽略常量、低次幂和最高次幂的系数。令f(n)=T(n)的数量级。</p>
<p>对于总量6n+4，忽略常量以后，f(n) = n;</p>
<p><strong>3. 用大O来表示时间复杂度。</strong></p>
<p>当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))。</p>
<p>所以最后得出T(n) = O(N)。</p>
<p>由于以上步骤比较繁琐，可以简化为以下步骤。</p>
<p>1. 找到执行次数最多的语句。<br>2. 计算语句执行次数的数量级。<br>3. 用大O来表示结果。</p>
<p>常见的时间复杂度有低到高的排列如下表，</p>
<table>
<thead>
<tr>
<th style="text-align:left">常数阶</th>
<th style="text-align:left">对数阶</th>
<th style="text-align:left">线性阶</th>
<th style="text-align:left">线性对数阶</th>
<th style="text-align:left">平方阶</th>
<th style="text-align:left">立方阶</th>
<th>…</th>
<th style="text-align:left">k次方阶</th>
<th>指数阶</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">O(1)</td>
<td style="text-align:left">O(log<sub>2</sub>n)</td>
<td style="text-align:left">O(n)</td>
<td style="text-align:left">O(nlog<sub>2</sub>n)</td>
<td style="text-align:left">O(n<sup>2</sup>)</td>
<td style="text-align:left">O(n<sup>3</sup>)</td>
<td>…</td>
<td style="text-align:left">O(n<sup>k</sup>)</td>
<td>O(2<sup>n</sup>)</td>
</tr>
</tbody>
</table>
<p>从上表中可以看出，我们在设计算法的时候，时间复杂度尽量向O(1)靠近。</p>
<h4 id="一些简单的法则">一些简单的法则</h4><p>1. For循环的运行时间至多是该for循环内语句的运行时间以迭代的次数，一般为O(N)。</p>
<p>2. 对于嵌套的for循环，从里面向外分析这些循环，在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小乘积。</p>
<p>例如，</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span>=<span class="number">0</span>; <span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++)</span><br><span class="line">   <span class="keyword">for</span> (int <span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">       k++;</span><br></pre></td></tr></table></figure>
<p>该程序片段为O(n<sup>2</sup>)。</p>
<h4 id="实例参考">实例参考</h4><p><strong>O(1)</strong></p>
<p>例如：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(i, j)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p>
<p><strong>O(n)</strong></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, <span class="keyword">sum</span>; <span class="comment">/* 1 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">/* 2 */</span></span><br><span class="line">        <span class="keyword">sum</span> += i;	<span class="comment">/* 3 */</span></span><br><span class="line">    printf(<span class="string">"%d"</span>, <span class="keyword">sum</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似前文所解析的Sum函数。</p>
<p><strong>O(log<sub>2</sub>n)</strong></p>
<p>首先看一个代码片段，</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span><span class="comment">; i &lt;= n; i = i * 2)</span></span><br><span class="line">   printf(<span class="string">"hello"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>设(i=i * 2)的频度是t, 则：2<sup>t</sup>(2的t次方)&lt;=n; 两边去对数t&lt;=log2n，考虑最坏情况，取最大值t=log2n。T(n) = O(log2n)。</p>
<p><strong>O(n<sup>2</sup>)</strong></p>
<p>参考一般法则中第二个。</p>
<p>参考</p>
<hr>
<p><a href="http://blog.csdn.net/fukaibo121/article/details/51019851" target="_blank" rel="external">http://blog.csdn.net/fukaibo121/article/details/51019851</a><br><a href="http://blog.csdn.net/u010297957/article/details/51016782" target="_blank" rel="external">大O符号与时间复杂度</a><br><a href="http://univasity.iteye.com/blog/1164707" target="_blank" rel="external">算法时间复杂度的计算[整理]</a><br><a href="https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly" target="_blank" rel="external">https://stackoverflow.com/questions/2307283/what-does-olog-n-mean-exactly</a></p>

            </div>
          

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/数据结构与算法/">数据结构与算法</a>
          
        </div>

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2017/09/10/data-struct-adt.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">抽象数据类型ADT(2)</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2017
    <span class="footer-author">Seymour.</span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=10001"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=10001"></script>

  </body>
</html>
